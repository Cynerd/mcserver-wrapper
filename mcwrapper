#!/usr/bin/env python3
# vim: expandtab ft=python ts=4 sw=4 sts=4:
import os
import sys
import subprocess
import signal
import time
import traceback
import atexit
from threading import Thread
from threading import Timer
import importlib.machinery as imp
###############################################################################
# Exit codes and prints helpers
_EC_OK = 0
_EC_ARG_UNKNOWN = 1
_EC_ARG_MULTIPLE_CONFIG = 2
_EC_MISSING_CONFIGURATION = 10
_EC_SERVER_RUNNING = 11


def __print_message__(message, file=sys.stdout, notime=False):
    if notime:
        print(message, file=file)
    else:
        print('[' + time.strftime('%H:%M:%S') + '] ' + message, file=file)


def info(message, minverbose=0, notime=False):
    "Prints message to stdout if minverbose >= verbose_level"
    try:
        if conf.verbose_level >= minverbose:
            __print_message__(message, notime=notime)
    except (NameError, TypeError):
        __print_message__(message, notime=notime)


def warning(message, minverbose=-1, notime=False):
    "Prints message to stderr if minverbose >= verbose_level"
    try:
        if conf.verbose_level >= minverbose:
            __print_message__(message, file=sys.stderr, notime=notime)
    except (NameError, TypeError):
        __print_message__(message, file=sys.stderr, notime=notime)


def error(message, minverbose=-2, ec=-1, notime=False):
    "Prints message to stderr if minverbose >= verbose_level"
    try:
        if conf.verbose_level >= minverbose:
            __print_message__(message, file=sys.stderr, notime=notime)
    except (NameError, TypeError):
        __print_message__(message, file=sys.stderr, notime=notime)
    sys.exit(ec)

###############################################################################
# Load configuration

__all_config_files__ = (
    'mcwrapper.conf',
    '~/.mcwrapper.conf',
    '~/.config/mcwrapper.conf',
    '/etc/mcwrapper.conf',
    )


def load_conf(config_file):
    """Load config_file to conf variable. Or if it has value None, search on
    default paths"""
    global conf

    def __set_empty_config__():
        global conf
        warning('User configuration not loaded. Using default.')
        conf = type('default config', (object,), {})
    if config_file is None:
        # Find configuration in predefined paths
        for cf in __all_config_files__:
            if os.path.isfile(os.path.expanduser(cf)):
                config_file = os.path.expanduser(cf)
                break
    if config_file is None:  # If no configuration find. Set empty config
        __set_empty_config__()
    else:  # else load configuration
        try:
            conf = imp.SourceFileLoader("conf", config_file).load_module()
        except Exception:
            traceback.print_exc()
            __set_empty_config__()
    # Set additional runtime configuration variables
    if 'verbose_level' not in vars(conf):
        conf.verbose_level = 0


def __conf_check_bad_type__(config):
    error('Bad configuration type of configuration option: ' + config,
          ec=_EC_MISSING_CONFIGURATION)


def __conf_check_missing__(config):
    error('Missing configuration option: ' + config,
          ec=_EC_MISSING_CONFIGURATION)


def __conf_check_no_dir__(directory):
    error('No directory exists for configuration option: ' + directory,
          ec=_EC_MISSING_CONFIGURATION)


def conf_checkserver(server):
    "Check and set configuration for server specified as agument."
    try:
        srv = vars(conf)[server]
    except KeyError:
        error("No configuration class found", ec=_EC_MISSING_CONFIGURATION)
    if 'timeout' not in vars(srv):
        srv.timeout = 0
    if isinstance(srv.timeout) != int:
        __conf_check_bad_type__('timeout')
    if 'directory' not in vars(srv):
        __conf_check_missing__('directory')
    if isinstance(srv.directory) != str:
        __conf_check_bad_type__('directory')
    srv.directory = os.path.expanduser(srv.directory)
    if not os.path.isdir(srv.directory):
        __conf_check_no_dir__('directory')
    if 'command' not in vars(srv):
        __conf_check_missing__('command')
    if isinstance(srv.command) != str:
        __conf_check_bad_type__('command')
    if 'statusdir' not in vars(srv):
        srv.statusdir = '/dev/shm/mcwrapper-' + server
    if isinstance(srv.statusdir) != str:
        __conf_check_bad_type__('statusdir')
    srv.statusdir = os.path.expanduser(srv.statusdir)
    return srv

###############################################################################
# Minecraft server

__STATUSSTRINGS__ = {
    0: "Not running",
    1: "Starting",
    2: "Running",
    3: "Stopping",
    }


class MCServer:
    def __init__(self, identifier, conf):
        self.identifier = identifier
        self.players = set()
        self.status = 0
        self.conf = conf
        self.prc = None
        self.shutdownTimeout = None
        self.inputPipe = self.conf.statusdir + '/input_pipe'
        self.statusFile = self.conf.statusdir + '/status'
        self.playersFile = self.conf.statusdir + '/players'
        self.pidfile = self.conf.statusdir + '/server.pid'
        if isinstance(self.conf.command) != str:
            self.conf.command = ' '.join(self.conf.command)
        info("Server wrapper initializing")
        info("Folder: " + self.conf.directory, 1)
        info("Start command: " + self.conf.command, 1)
        try:
            os.mkdir(self.conf.statusdir)
        except FileExistsError:
            pass
        try:
            os.mkfifo(self.inputPipe, 0o640)
        except FileExistsError:
            pass
        if os.path.isfile(self.pidfile):
            with open(self.pidfile) as f:
                lpid = int(f.readline())
            try:
                os.kill(lpid, 0)
            except OSError:
                warning("Detected forced termination of previous server "
                        "wrapper instance.")
            else:
                error("Another wrapper is running with given identifier.",
                      -1, _EC_SERVER_RUNNING)
        with open(self.statusFile, 'w') as f:
            f.write(__STATUSSTRINGS__[0] + '\n')
        with open(self.playersFile, 'w') as f:
            pass
        self.inputThread = Thread(target=self.__input_thread__,
                                  daemon=True)
        self.outpuThread = Thread(target=self.__output_thread__,
                                  daemon=True)

    def clean(self):
        info("Server wrapper clean.")
        try:
            os.remove(self.inputPipe)
        except FileNotFoundError:
            pass
        try:
            os.remove(self.statusFile)
        except FileNotFoundError:
            pass
        try:
            os.remove(self.playersFile)
        except FileNotFoundError:
            pass
        if os.path.isfile(self.pidfile):
            os.remove(self.pidfile)

    def execstart(self):
        "Start execution of server"
        self.start()
        self.prc.wait()

    def start(self):
        "Start Minecraft server"
        self.prc = subprocess.Popen(
            self.conf.command, stdin=subprocess.PIPE,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True,
            start_new_session=False,
            cwd=os.path.expanduser(self.conf.directory))
        with open(self.pidfile, "w") as f:
            f.write(str(self.prc.pid))
        self.status = 1
        with open(self.statusFile, 'w') as f:
            f.write(__STATUSSTRINGS__[1] + '\n')
        if not self.inputThread.is_alive():
            self.inputThread.start()
        if not self.outpuThread.is_alive():
            self.outpuThread.start()

    def stop(self):
        if self.running():
            self.prc.stdin.write(bytes("/stop\n", sys.getdefaultencoding()))
            self.prc.stdin.flush()
            self.__autoshutdown_disable__()

    def running(self):
        "Returns True if mc server is running. Othervise False."
        if self.status:
            return True
        else:
            return False

    def write_to_terminal(self, text):
        "Write to server terminal. If server not running it does nothing"
        if self.status == 2:
            info("Input: " + text, 1)
            self.prc.stdin.write(bytes(text, sys.getdefaultencoding()))
            self.prc.stdin.flush()
            return True
        else:
            return False

    def __autoshutdown_enable__(self):
        if self.conf.timeout > 0:
            info("Automatic shutdown after " + str(self.conf.timeout) +
                 " min.")
            self.shutdownTimeout = Timer(self.conf.timeout * 60.0, self.stop)
            self.shutdownTimeout.start()

    def __autoshutdown_disable__(self):
        try:
            self.shutdownTimeout.cancel()
            del self.shutdownTimeout
            info("Automatic shutdown disabled.")
        except AttributeError:
            pass

    def __user_join__(self, username):
        info("User '" + username + "' joined server.")
        self.players.add(username)
        with open(self.playersFile, 'a') as f:
            f.write(username + '\n')
        self.__autoshutdown_disable__()

    def __user_leave__(self, username):
        info("User '" + username + "' left server.")
        self.players.remove(username)
        with open(self.playersFile, 'w') as f:
            f.writelines(self.players)
            if self.players:
                f.write('\n')
        if not self.players:
            self.__autoshutdown_enable__()

    def __parse_line__(self, line):
        if ': Done' in line:
            info("Server start.")
            self.status = 2
            with open(self.statusFile, 'w') as f:
                f.write(__STATUSSTRINGS__[2] + '\n')
            self.__autoshutdown_enable__()
        elif ': Stopping the server' in line:
            info("Server stop.")
            self.status = 3
            with open(self.statusFile, 'w') as f:
                f.write(__STATUSSTRINGS__[3] + '\n')
        elif 'logged in with entity id' in line:
            name = line[len('[00:00:00] [Server thread/INFO]: '):]
            name = name[:name.index('[')]
            self.__user_join__(name)
        elif 'left the game' in line:
            name = line[len('[00:00:00] [Server thread/INFO]: '):]
            name = name[:name.index(' ')]
            self.__user_leave__(name)

    def __output_thread__(self):
        for linen in self.prc.stdout:
            line = linen.decode(sys.getdefaultencoding())
            info(line.rstrip(), 2, notime=True)
            self.__parse_line__(line.rstrip())
        with open(self.statusFile, 'w') as f:
            f.write(__STATUSSTRINGS__[0] + '\n')

    def __input_thread__(self):
        with open(self.inputPipe, 'r') as p:
            while True:
                ln = p.readline().rstrip()
                if ln:
                    self.write_to_terminal(ln + "\n")
                else:
                    time.sleep(3)

###############################################################################


def wrapper_atexit():
    "This is called when wrapper is exiting"
    _mcserver.clean()


def wrapper_toexit():
    "This function is called when system signalizes that mcwrapper should exit"
    _mcserver.stop()


def __signal_term__(_signo, _stack_frame):
    wrapper_toexit()


def print_help():
    print('mcwrapper [arguments...] IDENTIFIER')
    print('  This script is executing Minecraft server and reads its output.')
    print('  From output isextracted server status and list of online')
    print('  players.')
    print('')
    print(' arguments')
    print('   -h, --help')
    print('       Prints this help text.')
    print('   -v, --verbose')
    print('       Increase verbose level of output.')
    print('   -q, --quiet')
    print('       Decrease verbose level of output.')
    print('   --config CONFIG_FILE')
    print('       Specify configuration file to be used.')
    print('   --configfile')
    print('       prints used configuration file and exits.')
    print(' IDENTIFIER')
    print('   Identifier for new server. This allows multiple servers')
    print('   running with this wrapper.  Identifier is word without')
    print('   spaces and preferably without special characters.')
    sys.exit(_EC_OK)


def print_conffile():
    if '__file__' in vars(conf):
        print(conf.__file__)
    else:
        print("No configuration file used.")
    sys.exit(_EC_OK)


if __name__ == '__main__':
    identifier = None
    use_config = None
    verbose_level = 0
    print_config_file = False
    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        i += 1
        if arg[0] == '-':
            if len(arg) > 2 and arg[1] == '-':
                if arg == '--help':
                    print_help()
                elif arg == '--verbose':
                    verbose_level += 1
                elif arg == '--quiet':
                    verbose_level += 1
                elif arg == '--config':
                    if use_config is not None:
                        error('Config option is used multiple times',
                              ec=_EC_ARG_MULTIPLE_CONFIG)
                    else:
                        use_config = sys.argv[i]
                        i += 1
                elif arg == '--configfile':
                    print_config_file = True
                continue
            else:
                for l in arg[1:]:
                    if l == 'h':
                        print_help()
                    elif l == 'v':
                        verbose_level += 1
                    elif l == 'q':
                        verbose_level -= 1
                    else:
                        error("Unknown short argument " + l,
                              ec=_EC_ARG_UNKNOWN)
                continue
        if identifier is None:
            identifier = arg
            continue
        error("Unknown argument: " + arg, ec=_EC_ARG_UNKNOWN)
    # Parsing args ends

    load_conf(use_config)

    if print_config_file:
        print_conffile()

    conf.verbose_level += verbose_level
    # Set identifier if provided
    if identifier:
        conf.identifier = identifier
    elif "identifier" not in vars(conf):
        print_help()

    server_conf = conf_checkserver(conf.identifier)
    _mcserver = MCServer(conf.identifier, server_conf)
    signal.signal(signal.SIGTERM, __signal_term__)
    signal.signal(signal.SIGINT, __signal_term__)
    atexit.register(wrapper_atexit)

    _mcserver.execstart()
