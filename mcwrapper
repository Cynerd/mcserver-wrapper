#!/usr/bin/env python3
import os
import sys
import re
import subprocess
import signal
import time
import datetime
import traceback
import atexit
from threading import Thread
from threading import Timer
import importlib.machinery as imp
#################################################################################
# Load configuration
# This segment is same as in mcmim

__all_config_files__ = (
        'mcwrapper.conf',
        '~/.mcwrapper.conf',
        '~/.config/mcwrapper.conf',
        '/etc/mcwrapper.conf',
        )

def __set_empty_config__():
    global conf
    print('Warning: User configuration not loaded. Using default.', file=sys.stderr)
    conf = type('default config', (object,), {})

def load_conf(config_file):
    global conf
    if config_file == None:
        # Find configuration in predefined paths
        for cf in __all_config_files__:
            if os.path.isfile(os.path.expanduser(cf)):
                config_file = os.path.expanduser(cf)
                break
    if config_file == None: # If no configuration find. Set empty config
        __set_empty_config__()
    else: # else load configuration
        try:
            conf = imp.SourceFileLoader("conf", config_file).load_module()
        except Exception:
            traceback.print_exc()
            __set_empty_config__()
    # Set additional runtime configuration variables
    if not 'verbose_level' in vars(conf):
        conf.verbose_level = 0
    if not 'server' in vars(conf):
        conf.server = dict()
    if not 'timeout' in vars(conf):
        conf.timeout = 0

#################################################################################

def autoshutdown_enable():
    global shutdownTimeout
    if (conf.timeout > 0):
        if (conf.verbose_level >= 0):
            print("Automatic shutdown after " + str(conf.timeout) +
                " min.")
        shutdownTimeout = Timer(conf.timeout * 60.0, __server_send_stop__)
        shutdownTimeout.start();
    pass

def autoshutdown_disable():
    global shutdownTimeout
    try:
        shutdownTimeout.cancel()
        del shutdownTimeout
        if (conf.verbose_level >= 0):
            print("Automatic shutdown disabled.")
    except NameError:
        pass

#################################################################################

__STATUSSTRINGS__ = {
    0: "Not running",
    1: "Starting",
    2: "Running",
    3: "Stopping",
    }

def __user_join__(username):
    global playersFile
    global players
    if conf.verbose_level >= 0:
        print("User '" + username + "' joined server.")
    with open(playersFile, 'a') as f:
        players.add(username)
        f.write(username + '\n')
    autoshutdown_disable()

def __user_leave__(username):
    global playersFile
    global players
    if conf.verbose_level >= 0:
        print("User '" + username + "' left server.")
    players.remove(username)
    with open(playersFile, 'w') as f:
        f.writelines(players)
        if players:
            f.write('\n')
    if (not players):
        autoshutdown_enable()

def __server_start__():
    if conf.verbose_level >= 0:
        print("Wrapper initializing with identifier: " + conf.identifier)
    try:
        os.mkdir(conf.status)
    except FileExistsError:
        pass
    try:
        os.mkfifo(inputPipe, 0o640)
    except FileExistsError:
        pass
    if os.path.isfile(pidfile):
        with open(pidfile) as f:
            lpid = int(f.readline())
        try:
            os.kill(lpid, 0)
        except OSError:
            if conf.verbose_level >= 0:
                print("Warning: Detected forced termination of previous wrapper instance")
        else:
            if conf.verbose_level >= -1:
                print("Error: Another wrapper is running with given identifier.")
            sys.exit(4)
    with open(statusFile, 'w') as f:
        f.write(__STATUSSTRINGS__[1] + '\n')
    with open(playersFile, 'w') as f:
        pass

def __server_clean__():
    if conf.verbose_level >= 0:
        print("Wrapper clean.")
    try:
        os.remove(inputPipe)
    except FileNotFoundError:
        pass
    try:
        os.remove(statusFile)
    except FileNotFoundError:
        pass
    try:
        os.remove(playersFile)
    except FileNotFoundError:
        pass
    if os.path.isfile(pidfile):
        os.remove(pidfile)

def __parse_line__(line):
    if ': Done' in line:
        print("Server start.")
        with open(statusFile, 'w') as f:
            f.write(__STATUSSTRINGS__[2] + '\n')
        autoshutdown_enable()
    elif ': Stopping the server' in line:
        print("Server stop.")
        with open(statusFile, 'w') as f:
            f.write(__STATUSSTRINGS__[3] + '\n')
    elif 'logged in with entity id' in line:
        name = line[len('[00:00:00] [Server thread/INFO]: '):]
        name = name[:name.index('[')]
        __user_join__(name)
    elif 'left the game' in line:
        name = line[len('[00:00:00] [Server thread/INFO]: '):]
        name = name[:name.index(' ')]
        __user_leave__(name)

#################################################################################

class __InputThread__(Thread):
    def __init__(self, pipeprocess):
        Thread.__init__(self, name='InputThread')
        self.pipeprocess = pipeprocess
        self.stopread = False
    def stopexec(self):
        self.stopread = True
    def wake(self):
        with open(inputPipe, 'w') as f:
            f.write("\n")
            f.flush()
    def run(self):
        with open(inputPipe, 'r') as p:
            while not self.stopread:
                ln = p.readline()
                if ln.rstrip():
                    if conf.verbose_level >= 1:
                        print("Input: " + ln, end="")
                    self.pipeprocess.write(bytes(ln, sys.getdefaultencoding()))
                    self.pipeprocess.flush()
                else:
                    time.sleep(1)

def __server_send_stop__():
    global prc
    prc.stdin.write(bytes("/stop\n", sys.getdefaultencoding()))
    prc.stdin.flush()

def mcexec():
    """Executes cmd and parses output for server status changes.
    """
    global prc
    if type(conf.command) != str:
        conf.command = ' '.join(conf.command)
    if conf.verbose_level >= 1:
        print("Folder: " + conf.directory)
        print("Start command: " + conf.command)
    os.chdir(os.path.expanduser(conf.directory))
    prc = subprocess.Popen(conf.command, stdin=subprocess.PIPE,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True,
             start_new_session=False)
    with open(pidfile, "w") as f:
        f.write(str(prc.pid))
    inputThread = __InputThread__(prc.stdin)
    inputThread.start()
    inputThread.wake() # Input thread is stuck in waiting for first line
    for linen in prc.stdout:
        line = linen.decode(sys.getdefaultencoding())
        if conf.verbose_level >= 2:
            print(line.rstrip())
        __parse_line__(line.rstrip())
    inputThread.stopexec()

#################################################################################

def __signal_term__(_signo, _stack_frame):
    __server_send_stop__()

def print_help():
    print('mcwrapper [arguments...] IDENTIFIER')
    print('  This script is executing Minecraft server and reads its output. From output is')
    print('  extracted server status and list of online players.')
    print('')
    print(' arguments')
    print('   -h, --help')
    print('       Prints this help text.')
    print('   -v, --verbose')
    print('       Increase verbose level of output.')
    print('   -q, --quiet')
    print('       Decrease verbose level of output.')
    print('   --config CONFIG_FILE')
    print('       Specify configuration file to be used.')
    print(' IDENTIFIER')
    print('   Identifier for new server. This allows multiple servers running with this')
    print('   wrapper.  Identifier is word without spaces and preferably without special')
    print('   characters.')
    sys.exit()

if __name__ == '__main__':
    identifier = None
    use_config = None
    verbose_level = 0
    message = []
    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        i += 1
        if arg[0] == '-':
            if len(arg) > 2 and arg[1] == '-':
                if arg == '--help':
                    print_help()
                elif arg == '--verbose':
                    verbose_level += 1
                elif arg == '--quiet':
                    verbose_level += 1
                elif arg == '--config':
                    if use_config != None:
                        sys.exit('Config option is used multiple times')
                    else:
                        use_config = sys.argv[i]
                        i += 1
                continue
            else:
                for l in arg[1:]:
                    if l == 'h':
                        print_help()
                    elif l == 'v':
                        verbose_level += 1
                    elif l == 'q':
                        verbose_level -= 1
                    else:
                        sys.exit("Unknown short argument " + l)
                continue
        if identifier == None:
            identifier = arg
            continue
        sys.exit("Unknown argument: " + arg)
    # Parsing args ends

    load_conf(use_config)
    conf.verbose_level += verbose_level
    # Set identifier if provided
    if identifier:
        conf.identifier = identifier
    # Expand configuration for specified identifier
    if 'identifier' not in vars(conf):
        print('Missing server identifier argument!')
        print('')
        print_help()
    try:
        conf.server[conf.identifier]
        vars(conf).update(conf.server[conf.identifier])
    except KeyError:
        sys.exit('Error: No configuration associated with identifier: ' + conf.identifier)
    # Check configurations for server
    if not 'directory' in vars(conf):
        sys.exit('Missing "directory" config for server ' + conf.identifier)
    if not 'command' in vars(conf):
        sys.exit('Missing server start command for server ' + conf.identifier)
    if not 'status' in vars(conf):
        conf.status = '/dev/shm/mcwrapper-' + conf.identifier
    # Set inputPipe
    global inputPipe
    inputPipe = conf.status + '/input_pipe'
    global statusFile
    statusFile = conf.status + '/status'
    global playersFile
    playersFile = conf.status + '/players'
    global pidfile
    pidfile = conf.status + '/server.pid'
    global players
    players = set()

    signal.signal(signal.SIGTERM, __signal_term__)
    signal.signal(signal.SIGINT, __signal_term__)
    __server_start__()
    atexit.register(__server_clean__)
    mcexec()
